import requests
import zipfile
import io
import os
import logging
from datetime import datetime, time
from apscheduler.schedulers.background import BackgroundScheduler
from apscheduler.triggers.cron import CronTrigger
import shutil

logger = logging.getLogger(__name__)

class DatabaseUpdater:
    """Handles downloading and updating the malware database"""
    
    DOWNLOAD_URL = "https://bazaar.abuse.ch/export/csv/full/"
    
    def __init__(self, db_file_path: str):
        """
        Initialize the database updater
        
        Args:
            db_file_path: Path to the malware database CSV file
        """
        self.db_file_path = db_file_path
        self.scheduler = BackgroundScheduler()
        self.reload_callback = None
    
    async def download_and_update(self):
        """Download the latest malware database and update the local file"""
        try:
            logger.info(f"Downloading malware database from {self.DOWNLOAD_URL}")
            
            # Download the ZIP file
            response = requests.get(self.DOWNLOAD_URL, timeout=300)
            response.raise_for_status()
            
            logger.info(f"Downloaded {len(response.content)} bytes")
            
            # Extract the CSV from the ZIP file
            with zipfile.ZipFile(io.BytesIO(response.content)) as zip_file:
                # Get the first CSV file in the archive
                csv_files = [f for f in zip_file.namelist() if f.endswith('.csv')]
                
                if not csv_files:
                    logger.error("No CSV file found in the downloaded ZIP")
                    return False
                
                csv_filename = csv_files[0]
                logger.info(f"Extracting {csv_filename} from ZIP")
                
                # Create temporary file
                temp_file = f"{self.db_file_path}.tmp"
                
                # Extract to temporary location
                with zip_file.open(csv_filename) as source:
                    with open(temp_file, 'wb') as target:
                        shutil.copyfileobj(source, target)
                
                # Verify the file was written
                if os.path.exists(temp_file):
                    file_size = os.path.getsize(temp_file)
                    logger.info(f"Extracted database size: {file_size} bytes")
                    
                    # Replace the old database with the new one
                    os.makedirs(os.path.dirname(self.db_file_path), exist_ok=True)
                    
                    if os.path.exists(self.db_file_path):
                        os.remove(self.db_file_path)
                    
                    os.rename(temp_file, self.db_file_path)
                    
                    logger.info(f"Database updated successfully at {datetime.now()}")
                    
                    # Call reload callback if set
                    if self.reload_callback:
                        logger.info("Reloading database into memory")
                        self.reload_callback()
                    
                    return True
                else:
                    logger.error("Failed to extract database file")
                    return False
                    
        except requests.exceptions.RequestException as e:
            logger.error(f"Failed to download malware database: {e}")
            return False
        except zipfile.BadZipFile as e:
            logger.error(f"Invalid ZIP file: {e}")
            return False
        except Exception as e:
            logger.error(f"Error updating database: {e}")
            return False
    
    def start_scheduler(self, reload_callback=None):
        """
        Start the scheduler to update the database daily at 03:00
        
        Args:
            reload_callback: Function to call after database is updated
        """
        # Store callback so scheduled runs can refresh in-memory state
        self.reload_callback = reload_callback
        
        # Schedule daily update at 03:00
        trigger = CronTrigger(hour=3, minute=0)
        self.scheduler.add_job(
            self._scheduled_update,
            trigger=trigger,
            id='database_update',
            name='Daily malware database update',
            replace_existing=True
        )
        
        self.scheduler.start()
        logger.info("Scheduler started - database will update daily at 03:00")
    
    def _scheduled_update(self):
        """Internal method for scheduled updates (synchronous wrapper)"""
        import asyncio
        
        # Create a new event loop for the scheduled task
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        
        try:
            loop.run_until_complete(self.download_and_update())
        finally:
            # close the event loop to avoid resource leaks
            loop.close()
    
    def stop_scheduler(self):
        """Stop the scheduler"""
        if self.scheduler.running:
            self.scheduler.shutdown()
            logger.info("Scheduler stopped")
    
    def get_next_update_time(self):
        """Get the next scheduled update time"""
        # Read the next_run_time from the scheduled job (if it exists)
        job = self.scheduler.get_job('database_update')
        if job:
            return job.next_run_time
        return None

#!/usr/bin/env python3
# Copyright (C) 2015-2024, Wazuh Inc.
# Custom integration for Malware API

import json
import sys
import os
import time
import requests
from requests.exceptions import ConnectionError, RequestException

# Define global variables
DEBUG_ENABLED = False
# Request timeout for malware-api calls (seconds)
# Can be overridden via env var MALWARE_API_TIMEOUT
API_TIMEOUT =  int(os.environ.get("MALWARE_API_TIMEOUT", "30"))


def main(args):
    """Main function to process Wazuh alerts and query malware-api."""
    debug("# Starting malware-api integration")
    debug(f"# Args received: {args}")
    debug(f"# Number of args: {len(args)}")

    # Small delay to ensure Wazuh is ready (helps with first request timing issues)
    time.sleep(0.1)

    # Read configuration parameters
    alert_file_location = args[1]
    api_key = args[2] if len(args) > 2 else ""
    hook_url = args[3] if len(args) > 3 else ""

    debug(f"# Alert file location: {alert_file_location}")
    debug(f"# API URL: {hook_url}")
    debug(f"# API Key length: {len(api_key)}")

    # Validate configuration
    if not hook_url:
        debug("# Error: hook_url is required")
        sys.exit(1)

    if not api_key:
        debug("# Error: api_key is required")
        sys.exit(1)

    # Read alert from file
    alert_json = read_alert_file(alert_file_location)
    debug(f"# Alert rule ID: {alert_json.get('rule', {}).get('id')}")
    debug(f"# Alert timestamp: {alert_json.get('timestamp')}")

    # Extract file hash from alert
    file_hash = extract_hash_from_alert(alert_json)

    if not file_hash:
        debug("# No file hash found in alert, skipping")
        return

    debug(f"# Extracted hash: {file_hash}")

    # Extract additional information from alert
    agent_name = alert_json.get("agent", {}).get("name", "unknown")
    file_path = alert_json.get("syscheck", {}).get("path", "unknown")
    username = alert_json.get("syscheck", {}).get("uname_after") or alert_json.get("data", {}).get("username", None)
    timestamp = alert_json.get("timestamp", None)

    debug(f"# Agent: {agent_name}")
    debug(f"# Path: {file_path}")
    debug(f"# Username: {username}")
    debug(f"# Timestamp: {timestamp}")

    # Query malware-api
    debug(f"# Starting malware-api query...")
    malware_info = query_malware_api(hook_url, api_key, file_hash, agent_name, file_path, username, timestamp)

    if malware_info and malware_info.get("is_malware"):
        debug("# Malware detected! Generating alert...")
        generate_alert(alert_json, malware_info, is_malware=True)
        debug("# Malware alert generated successfully")
    elif malware_info:
        debug("# File is clean. Generating alert...")
        generate_alert(alert_json, malware_info, is_malware=False)
        debug("# Clean file alert generated successfully")
    else:
        debug("# No response from malware-api, cannot generate alert")
    
    debug("# Integration processing complete")


def read_alert_file(alert_file_location):
    """Read and parse the alert JSON file."""
    try:
        with open(alert_file_location) as alert_file:
            return json.load(alert_file)
    except Exception as e:
        debug(f"# Error reading alert file: {str(e)}")
        sys.exit(1)


def extract_hash_from_alert(alert_json):
    """Extract file hash from Wazuh alert.
    
    Returns:
        str: hash_value or None if not found
    """
    # Check syscheck (FIM) data
    syscheck = alert_json.get("syscheck", {})
    
    # Try to get SHA256 hash (preferred)
    sha256 = syscheck.get("sha256_after") or syscheck.get("sha256_before")
    if sha256:
        return sha256
    
    # Try MD5 hash
    md5 = syscheck.get("md5_after") or syscheck.get("md5_before")
    if md5:
        return md5
    
    # Try SHA1 hash
    sha1 = syscheck.get("sha1_after") or syscheck.get("sha1_before")
    if sha1:
        return sha1
    
    return None


def query_malware_api(hook_url, api_key, file_hash, agent_name, file_path, username=None, timestamp=None):
    """Query the malware-api to check if hash is malware.
    
    Returns:
        dict: Malware information or None if request fails
    """
    # Prepare API endpoints
    health_url = f"{hook_url.rstrip('/')}/health"
    api_url = f"{hook_url.rstrip('/')}/check"
    
    headers = {
        "X-API-Key": api_key,
        "Content-Type": "application/json"
    }
    
    payload = {
        "hash": file_hash,
        "agent_name": agent_name,
        "path": file_path
    }
    
    # Add username if available
    if username:
        payload["username"] = username
    
    # Add timestamp if available
    if timestamp:
        payload["timestamp"] = timestamp
    
    debug(f"# Preflight health check: {health_url}")
    # Preflight: ensure API is healthy (database loaded) before first call
    try:
        for i in range(5):  # up to ~5 seconds
            hr = requests.get(health_url, timeout=2)
            if hr.status_code == 200 and hr.json().get("status") == "healthy":
                debug("# Malware-API health OK")
                break
            debug(f"# Health not ready (attempt {i+1}) status={hr.status_code}")
            time.sleep(1)
    except Exception as he:
        debug(f"# Health check error (continuing anyway): {str(he)}")

    debug(f"# Querying malware-api: {api_url}")
    debug(f"# API Key: {api_key[:10]}...")
    debug(f"# Payload: {json.dumps(payload)}")
    
    # Try up to 2 attempts; first may timeout while LLM warms up
    attempts = 2
    for attempt in range(attempts):
        try:
            debug(f"# Making POST request to {api_url} (attempt {attempt+1}) with timeout={API_TIMEOUT}s...")
            response = requests.post(
                api_url,
                headers=headers,
                json=payload,
                timeout=API_TIMEOUT
            )
            debug(f"# Response status code: {response.status_code}")
            response.raise_for_status()
            
            result = response.json()
            debug(f"# API response received: {json.dumps(result, indent=2)}")
            debug(f"# Response is_malware: {result.get('is_malware')}")
            return result
            
        except requests.Timeout as te:
            debug(f"# TIMEOUT calling malware-api (attempt {attempt+1}/{attempts}): {str(te)}")
            if attempt < attempts - 1:
                debug("# Retrying after short backoff...")
                time.sleep(1)
            else:
                return None
        except ConnectionError as e:
            debug(f"# ERROR: Connection error connecting to malware-api at {api_url}: {str(e)}")
            return None
        except RequestException as e:
            debug(f"# ERROR: Request exception querying malware-api: {str(e)}")
            return None
        except Exception as e:
            debug(f"# ERROR: Unexpected error: {str(e)}")
            return None


def generate_alert(original_alert, malware_info, is_malware=True):
    """Generate enriched alert with malware information."""
    # Create enriched alert
    alert_output = {
        "malware_api": {
            "found": 1,
            "malware": is_malware,
            "hash": malware_info.get("hash"),
            "hash_type": malware_info.get("hash_type")
        },
        "integration": "malware-api"
    }
    
    # Add malware details if available (only for malware)
    if is_malware:
        details = malware_info.get("details", {})
        if details:
            alert_output["malware_api"]["details"] = {
                "first_seen": details.get("first_seen"),
                "file_name": details.get("file_name"),
                "file_type": details.get("file_type"),
                "signature": details.get("signature"),
                "reporter": details.get("reporter")
            }

    # Add title/explanation for both malware and clean cases
    agent_name = (
        original_alert.get("agent", {}).get("name")
        or malware_info.get("agent_name")
        or "this system"
    )
    title_val = malware_info.get("title")
    explanation_val = malware_info.get("explanation")
    if not is_malware:
        if not title_val:
            title_val = "No malware detected"
        if not explanation_val:
            explanation_val = f"No malware detected on {agent_name}"
    if title_val:
        alert_output["malware_api"]["title"] = title_val
    if explanation_val:
        alert_output["malware_api"]["explanation"] = explanation_val
    
    # Merge with original alert data
    alert_output.update({
        "rule": original_alert.get("rule", {}),
        "agent": original_alert.get("agent", {}),
        "syscheck": original_alert.get("syscheck", {}),
        "decoder": original_alert.get("decoder", {}),
        "location": original_alert.get("location", ""),
        "timestamp": original_alert.get("timestamp", "")
    })
    
    # Send alert to Wazuh analysisd
    send_alert_to_wazuh(alert_output)


def send_alert_to_wazuh(alert):
    """Send enriched alert to Wazuh analysisd via socket."""
    debug(f"# Sending alert to Wazuh - hash={alert.get('malware_api', {}).get('hash', 'N/A')[:16]}...")
    debug(f"# Alert structure: malware={alert.get('malware_api', {}).get('malware')}, has_title={('title' in alert.get('malware_api', {}))}")
    
    # Print to stdout for logging in integrations.log
    alert_json_str = json.dumps(alert)
    debug(f"# Alert JSON length: {len(alert_json_str)}")
    debug(f"# Alert JSON first 200 chars: {alert_json_str[:200]}")
    
    print(alert_json_str)
    sys.stdout.flush()
    debug("# Alert printed to stdout and flushed")
    
    # Send to analysisd queue for rule processing
    try:
        from socket import socket, AF_UNIX, SOCK_DGRAM
        
        pwd = os.path.dirname(os.path.dirname(os.path.realpath(__file__)))
        socket_addr = f'{pwd}/queue/sockets/queue'
        
        debug(f"# Socket path: {socket_addr}")
        debug(f"# Checking if socket exists: {os.path.exists(socket_addr)}")
        
        agent = alert.get('agent', {})
        
        # Format message for Wazuh socket
        if not agent or agent.get('id') == '000':
            string = '1:custom-malware:{0}'.format(json.dumps(alert))
        else:
            # Build location string: [agent_id] (agent_name) agent_ip
            location = '[{0}] ({1}) {2}'.format(
                agent.get('id', '000'),
                agent.get('name', 'unknown'),
                agent.get('ip', 'any')
            )
            # Escape special characters
            location = location.replace('|', '||').replace(':', '|:')
            string = '1:{0}->custom-malware:{1}'.format(location, json.dumps(alert))
        
        debug(f"# Socket message length: {len(string)}")
        debug(f"# Attempting to send to socket...")
        
        # Send to socket with aggressive retry for startup timing issues
        max_retries = 10  # More retries for startup issues
        for attempt in range(max_retries):
            try:
                sock = socket(AF_UNIX, SOCK_DGRAM)
                sock.connect(socket_addr)
                sock.send(string.encode())
                sock.close()
                debug(f"# Alert sent to analysisd queue successfully (attempt {attempt + 1})")
                return
            except FileNotFoundError:
                # Socket doesn't exist yet - common on startup
                debug(f"# Socket not found (attempt {attempt + 1}/{max_retries}) - Wazuh may still be initializing")
                if attempt < max_retries - 1:
                    time.sleep(0.5)  # Wait 500ms before retry
            except ConnectionRefusedError:
                # Socket exists but connection refused - Wazuh analysisd not ready
                debug(f"# Connection refused (attempt {attempt + 1}/{max_retries}) - analysisd may still be starting")
                if attempt < max_retries - 1:
                    time.sleep(0.5)
            except Exception as sock_err:
                debug(f"# Socket error (attempt {attempt + 1}/{max_retries}): {str(sock_err)}")
                if attempt < max_retries - 1:
                    time.sleep(0.5)
        
        debug(f"# CRITICAL: Failed to send alert to Wazuh after {max_retries} retries - alert may be lost!")
    except Exception as e:
        debug(f"# Error in socket handling: {str(e)}")
        import traceback
        debug(traceback.format_exc())


def debug(msg):
    """Print debug message if DEBUG_ENABLED is True."""
    if DEBUG_ENABLED:
        print(msg, file=sys.stderr)
        sys.stderr.flush()


if __name__ == "__main__":
    try:
        # Enable debug mode from environment variable
        DEBUG_ENABLED = os.environ.get("WAZUH_INTEGRATION_DEBUG", "").lower() in ["1", "true", "yes"]
        main(sys.argv)
    except Exception as e:
        debug(f"# Fatal error: {str(e)}")
        sys.exit(1)
